package dsandalgo.random;

import java.util.Random;

/**
 * https://leetcode.com/problems/implement-rand10-using-rand7/
 * Given a function rand7 which generates a uniform random integer in the range 1 to 7, write a function
 * rand10 which generates a uniform random integer in the range 1 to 10.
 * Do NOT use system's Math.random().
 *
 * Example 1:
 * Input: 1
 * Output: [7]
 *
 * Example 2:
 * Input: 2
 * Output: [8,4]
 *
 * Example 3:
 * Input: 3
 * Output: [8,1,10]
 *
 * Note:
 *
 * rand7 is predefined.
 * Each testcase has one argument: n, the number of times that rand10 is called.
 *
 */
public class Rand7Rand10 {

    class SolBase{
        public int rand7(){
            Random rand = new Random();
            return rand.nextInt(7);
        }
    }
    class Solution extends SolBase {
        //Summary:
        //I assume rand7() represents the number from 0 to 6 which is more general in Java, please refer Random class
        // and nextInt(int bound): knock API door
        //
        //Key is uniform
        //rand7() * rand7(), rand7() + rand7() are not uniform because some numbers can be generated by different combinations
        //rand7() + rand7() != rand7() * 2 because rand7() + rand7() is not uniform, whereas rand7() * 2 is uniform
        //rand7()*c is uniform where c stands for constant integers. (But note: uniform here is meant by discrete numbers, to make the range continuously, we need to fill the gap by adding randc() => which then leads to OP solution)
        //So pattern we can conclude: k * randk + randk is uniform.(Note for the 3rd rule, don't mix it up with (k + 1)*randk)
        public int rand10() {
            while(true){
                int rand = 7*(rand7() - 1) + (rand7() - 1); // 0 to 48
                if(rand < 40) return rand % 10 + 1;
            }
        }
    }
    //https://leetcode.com/problems/implement-rand10-using-rand7/discuss/150301/Three-line-Java-solution-the-idea-can-be-generalized-to-%22Implement-RandM()-Using-RandN()%22

    //Idea: rand7() -> rand49() -> rand40() -> rand10()
    //
    //public int rand10() {
    //    int result = 40;
    //    while (result >= 40) {result = 7 * (rand7() - 1) + (rand7() - 1);}
    //    return result % 10 + 1;
    //}
    //Time Complexity
    //The total number of iterations follows geometric distribution. For each iteration in the while loop, the probabilty of exiting the loop is p = 40/49. So the average time complexity T(n) = O(1/p) = O(49/40) = O(1).
    //
    //Correctness
    //Note that rand49() generates a uniform random integer in [1, 49], so any number in this range has the same probability to be generated. Suppose k is an integer in range [1, 40], P(rand49() = k) = 1/49.
    //
    //   P(result = k)
    //= P(rand49() = k in the 1st iteration) +
    //   P(rand49() > 40 in the 1st iteration) * P(rand49() = k in the 2nd iteration) +
    //   P(rand49() > 40 in the 1st iteration) * P(rand49() > 40 in the 2nd iteration) * P(rand49() = k in the 3rd iteration) +
    //   P(rand49() > 40 in the 1st iteration) * P(rand49() > 40 in the 2nd iteration) * P(rand49() > 40 in the 3rd iteration) * P(rand49() = k in the 4th iteration) +
    //   ...
    //= (1/49) + (9/49) * (1/49) + (9/49)^2 * (1/49) + (9/49)^3 * (1/49) + ...
    //= (1/49) * [1 + (9/49) + (9/49)^2 + (9/49)^3 + ... ]
    //= (1/49) * [1/(1-9/49)]
    //= (1/49) * (49/40)
    //= 1/40
    //
    //Generalization
    //Implement randM() using randN() when M > N:
    //Step 1: Use randN() to generate randX(), where X >= M. In this problem, I use 7 * (rand7() - 1) + (rand7() - 1) to generate rand49() - 1.
    //Step 2: Use randX() to generate randM(). In this problem, I use rand49() to generate rand40() then generate rand10.
    //
    //Note: N^b * (randN() - 1) + N^(b - 1) * (randN() - 1) + N^(b - 2) * (randN() - 1) + ... + N^0 * (randN() - 1) generates randX() - 1, where X = N^(b + 1).
    //
    //More Examples
    //(1) Implement rand11() using rand3():
    //
    //public int rand11() {
    //    int result = 22;
    //    while (result >= 22) {result = 3 * 3 * (rand3() - 1) + 3 * (rand3() - 1) + (rand3() - 1);}
    //    return result % 11 + 1;
    //}
    //Idea: rand3() -> rand27() -> rand22 -> rand11
    //Time Comlexity: O(27/22)
    //
    //(2) Implement rand9() using rand7():
    //
    //public int rand9() {
    //    int result = 45;
    //    while (result >= 45) {result = 7 * (rand7() - 1) + (rand7() - 1);}
    //    return result % 9 + 1;
    //}
    //Idea: rand7() -> rand49() -> rand45() -> rand9()
    //Time Comlexity: O(49/45)
    //
    //(3) Implement rand13() using rand6():
    //
    //public int rand13() {
    //    int result = 26;
    //    while (result >= 26) {result = 6 * (rand6() - 1) + (rand6() - 1);}
    //    return result % 13 + 1;
    //}
    //Idea: rand6() -> rand36() -> rand26 -> rand13()
    //Time Comlexity: O(36/26)

}
